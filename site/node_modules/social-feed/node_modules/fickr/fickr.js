(function () {
  //WARNING: this shouldn't be used with node in a multi-user/
  //multi-server setup, at least not in its current form, because
  //user tokens are stored in global objects (as a result of its
  //initial development as a client-side only lib, and then its
  //current use as almost-client-only-but-with-single-user-back-end)
  
  //node or browser?
  var root = this;
  var fickr = new Object();
  var isNode = false;
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = fickr;
    root.fickr = fickr;
    isNode = true;
  } else {
    root.fickr = fickr;
  }

  //---utils----//:
  if (isNode) {
    var url = require('url');
    var http = require('http');
    var FormData = require('form-data');
  }
  var urlEncode = function (data) {
    var keys = Object.keys(data);
    for (var i=0; i<keys.length; i++) {
      keys[i] = keys[i] + '=' + data[keys[i]];
    }
    return keys.join('&');
  }
  var urlDecode = function (string) {
    var data = {};
    var pieces = string.split('&');
    for (var i=0; i<pieces.length; i++) {
      var sides = pieces[i].split('=');
      var key = decodeURIComponent(sides[0]);
      var val = decodeURIComponent(sides[1]);
      data[key] = val;
    }
    return data;
  }
  var HMAC_SHA1 = function(k,d,_p,_z) {
    //the following was taken from https://github.com/jrconlin/oauthsimple/blob/master/js/OAuthSimple.js

    //_p = b64pad, _z = character size; not used here but I left them available just in case
    if (!_p) {_p = '=';}if (!_z) {_z = 8;}function _f(t,b,c,d) {if (t < 20) {return (b & c) | ((~b) & d);}if (t < 40) {return b^c^d;}if (t < 60) {return (b & c) | (b & d) | (c & d);}return b^c^d;}function _k(t) {return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514;}function _s(x,y) {var l = (x & 0xFFFF) + (y & 0xFFFF), m = (x >> 16) + (y >> 16) + (l >> 16);return (m << 16) | (l & 0xFFFF);}function _r(n,c) {return (n << c) | (n >>> (32 - c));}function _c(x,l) {x[l >> 5] |= 0x80 << (24 - l % 32);x[((l + 64 >> 9) << 4) + 15] = l;var w = [80], a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, e = -1009589776;for (var i = 0; i < x.length; i += 16) {var o = a, p = b, q = c, r = d, s = e;for (var j = 0; j < 80; j++) {if (j < 16) {w[j] = x[i + j];}else {w[j] = _r(w[j - 3]^w[j - 8]^w[j - 14]^w[j - 16], 1);}var t = _s(_s(_r(a, 5), _f(j, b, c, d)), _s(_s(e, w[j]), _k(j)));e = d;d = c;c = _r(b, 30);b = a;a = t;}a = _s(a, o);b = _s(b, p);c = _s(c, q);d = _s(d, r);e = _s(e, s);}return [a, b, c, d, e];}function _b(s) {var b = [], m = (1 << _z) - 1;for (var i = 0; i < s.length * _z; i += _z) {b[i >> 5] |= (s.charCodeAt(i / 8) & m) << (32 - _z - i % 32);}return b;}function _h(k,d) {var b = _b(k);if (b.length > 16) {b = _c(b, k.length * _z);}var p = [16], o = [16];for (var i = 0; i < 16; i++) {p[i] = b[i]^0x36363636;o[i] = b[i]^0x5C5C5C5C;}var h = _c(p.concat(_b(d)), 512 + d.length * _z);return _c(o.concat(h), 512 + 160);}function _n(b) {var t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', s = '';for (var i = 0; i < b.length * 4; i += 3) {var r = (((b[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) | (((b[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8) | ((b[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);for (var j = 0; j < 4; j++) {if (i * 8 + j * 6 > b.length * 32) {s += _p;}else {s += t.charAt((r >> 6 * (3 - j)) & 0x3F);}}}return s;}function _x(k,d) {return _n(_h(k, d));}return _x(k, d);
  };
  var jsonp = function (url, data, callback) {
    var urlString = url + '?' + urlEncode(data);

    fickr.jsonpResponses[data.jsoncallback] = null;
    window[data.jsoncallback] = function (resp) {
      fickr.jsonpResponses[data.jsoncallback] = resp;
      callback(resp);
    };

    //if timeout occurs before callback, throw error
    setTimeout(function() {
      if (!fickr.jsonpResponses[data.jsoncallback]) throw "Error: JSONP requestto "+urlString+" has timed out."
      delete window[data.callback];
    }, 5000);

    //load JSONP resource
    var script = document.createElement('script');
    script.src = urlString;
    document.getElementsByTagName('head')[0].appendChild(script);
  }
  var iframePost = function (url, data, callback) {
    var iframe = document.createElement('iframe');
    iframe.setAttribute("id", "upload_iframe");
    iframe.setAttribute("name", "upload_iframe");
    iframe.setAttribute("width", "0");
    iframe.setAttribute("height", "0");
    iframe.setAttribute("border", "0");
    iframe.setAttribute("style", "width: 0; height: 0; border: none;");

    document.body.appendChild(iframe);
    window.frames['upload_iframe'].name = "upload_iframe";

    var form = document.createElement('form');
    form.setAttribute('method','POST');
    form.setAttribute('target','upload_iframe');
    form.setAttribute('action',url);
    form.setAttribute('enctype','multipart/form-data');
    form.setAttribute('encoding','multipart/form-data');

    var keys = Object.keys(data);
    for (var i=0; i<keys.length; i++) {
      var input;
      if (keys[i] == 'photo') {
        input = data[keys[i]];
      } else {
        input = document.createElement('input');
        input.setAttribute('name',keys[i]);
        input.setAttribute('value',data[keys[i]]);
      }
      form.appendChild(input);
    }
    form.setAttribute('style','display:none;');
    document.body.appendChild(form);
    form.submit();
  }

  //---meat---//:
  fickr.jsonpResponses = {};

  fickr.init = function (consumerKey,consumerSecret,userId,userKey,userSecret) {
    fickr.consumerKey = consumerKey;
    fickr.consumerSecret = consumerSecret;
    fickr.userId = userId;
    fickr.userKey = userKey;
    fickr.userSecret = userSecret;
  }

  fickr.signedRequest = function (options,callback) {
    if (!options.url) throw "Can't request undefined URL";
    if (!options.data) options.data = {};
    if (!options.method) options.method = 'GET';
    if (!options.data.oauth_token) {
      options.secret = '';
    } else if (!options.secret) {
      throw "Can't request for token "+ options.data.token + " without secret."
    }

    options.data.oauth_nonce = Math.floor(Math.random()*90000000) + 10000000;
    options.data.oauth_timestamp = Math.floor(new Date() / 1000);
    options.data.oauth_signature_method='HMAC-SHA1';
    options.data.oauth_version = '1.0';
    options.data.oauth_consumer_key = fickr.consumerKey;
    options.data.format = 'json';
    if (!isNode && options.method == 'GET') {//browser GET
      options.data.jsoncallback = 'jsonp'+options.data.oauth_nonce;
    } else {
      options.data.nojsoncallback = '1';
    }

    var keys = Object.keys(options.data).sort();
    var urlParams = [];
    var text = options.method + '&' + encodeURIComponent(options.url) + '&';
    for (var i=0; i<keys.length; i++) {
      urlParams.push(encodeURIComponent(keys[i] + '=' + encodeURIComponent(options.data[keys[i]])));
    }
    text = text + urlParams.join(encodeURIComponent('&'));
    var key = fickr.consumerSecret + '&' + options.secret;
    options.data.oauth_signature = HMAC_SHA1(key,text);

    if (!isNode) {//browser
      if (options.method == 'GET') {
        options.data.oauth_signature = encodeURIComponent(
            options.data.oauth_signature);
        jsonp(options.url,options.data,callback);
      } else {
        if (options.photo) options.data.photo = options.photo;
        iframePost(options.url,options.data,callback);
      }
    } else {//node
      var urlPieces = url.parse(options.url);
      if (options.method == 'GET') {
        options.data.oauth_signature = encodeURIComponent(
            options.data.oauth_signature);
        urlPieces.path = urlPieces.path + '?' + urlEncode(options.data);
      }
      var reqOpts = {
        host:urlPieces.host,
        path:urlPieces.path,
        method:options.method
      };
      if (options.photo) {
        var form = new FormData();
        for (var key in options.data) {
          form.append(key,options.data[key]);
        }
        form.append('photo',options.photo,{'knownLength':79850});

        form.submit(reqOpts, function(err, res) {
          if (err) throw err;
          var data = [];
          res.setEncoding('utf8');
          res.on('data',function(chunk) {
            data.push(chunk);
          });
          res.on('end',function() {
            callback(data.join(''));
          });
        });
      } else {
        var req = http.request(reqOpts,function(res) {
          res.setEncoding('utf8');
          var data = [];
          res.on('data',function(chunk) {
            data.push(chunk);
          });
          res.on('end',function() {
            callback(data.join(''));
          });
        });
        req.on('error', function(e) {
          throw "Error: request failed."
        });
        if (options.method != 'GET') req.write(urlEncode(options.data));
        req.end();
      }
    }
  }

  fickr.upload = function(callback,fileInputElement,options) {
    options.oauth_token = fickr.userKey;
    var request = {
      'method': 'POST',
      'url': 'http://up.flickr.com/services/upload',
      'data': options,
      'secret': fickr.userSecret,
      'photo':fileInputElement
    };
    if (isNode) {
      fickr.signedRequest(request,callback);
    } else {
      fickr.fetch(function (data) {
        fickr.beforeUpload = JSON.stringify(data);
        fickr.signedRequest(request,console.log);
      });
      setTimeout(function () {
        fickr.fetch(function (data) {
          fickr.afterUpload = JSON.stringify(data);
          if (fickr.beforeUpload == fickr.afterUpload) {
            throw "Error: Could not upload file.";
          } else {
            callback({'success':true,'data':data});
          }
        });
      }, 10000);
    }
  }

  fickr.fetch = function(callback,options) {
    options.extras = options.extras || 'description,tags,machine_tags,url_q,url_sq,url_t,url_m,url_c,url_l';
    var request = {
      'method': 'GET',
      'url': 'http://api.flickr.com/services/rest/',
      'data': options,
      'secret': fickr.userSecret
    };
    request.data.method = 'flickr.people.getPhotos';
    request.data.oauth_token = fickr.userKey;
    request.data.user_id = fickr.userId;
    fickr.signedRequest(request,callback);
  }

  fickr.search = function(callback,options) {
    var request = {
      'method': 'GET',
      'url': 'http://api.flickr.com/services/rest/',
      'data': options,
      'secret': fickr.userSecret
    };
    request.data.method = 'flickr.photos.search';
    request.data.oauth_token = fickr.userKey;
    request.data.user_id = fickr.userId;
    fickr.signedRequest(request,callback);
  }

  fickr.listTags = function(callback) {
    var request = {
      'method': 'GET',
      'url':'http://api.flickr.com/services/rest/',
      'data': {
        'method': 'flickr.tags.getListUser',
        'user_id': fickr.userId
      }
    };
    fickr.signedRequest(request,callback);
  }

  if (isNode) {
    //the following utilities are for getting OAuth user tokens
    //(an implementation of the process decribed at
    //http://www.flickr.com/services/api/auth.oauth.html)
    //
    //Basically, calling getAuthURL will send a single argument
    //to its callback, a Flickr URL to which the user should be
    //sent.
    //
    //After the user authenticates the app at that URL, they get
    //redirected to callbackURL with some query parameters set:
    //    http://www.example.com/
    //    ?oauth_token=72157626737672178-022bbd2f4c2f3432
    //    &oauth_verifier=5d1b96a26b494074
    //Those parameters then need to be passed to getAccessToken
    //and the access token will be returned.
    //
    //These utilities use a shared memory object to persist
    //request tokens between getAuthURL and getAccessToken,
    //because it's expected that there won't be many request
    //tokens being stored at any point. Nevertheless, that could
    //obviously be improved at some point by using Redis or
    //whatever.
    fickr.getAuthURL = function (consumerKey,consumerSecret,callbackURL,callback) {
      fickr.consumerKey = consumerKey;
      fickr.consumerSecret = consumerSecret;
      var request = {
        'method': 'GET',
        'url': 'http://www.flickr.com/services/oauth/request_token',
        'data': {
          'oauth_callback': callbackURL
        }
      }
      fickr.signedRequest(request, function(data) {
        data = urlDecode(data);
        fickr.requestTokens = fickr.requestTokens || {}; //here's that memory object we could maybe do without
        fickr.requestTokens[data.oauth_token] = {'secret':data.oauth_token_secret};
        callback('http://www.flickr.com/services/oauth/authorize?oauth_token='+data.oauth_token);
      });
    }

    fickr.getAccessToken = function(requestToken,requestVerifier,callback) {
      requestObj = fickr.requestTokens[requestToken];
      requestObj.verifier = requestVerifier;
      var request = {
        'method': 'GET',
        'url': 'http://www.flickr.com/services/oauth/access_token',
        'data': {
          'oauth_token': requestToken,
          'oauth_verifier': requestObj.verifier
        },
        'secret': requestObj.secret
      }
      fickr.signedRequest(request,function(data) {
        delete fickr.requestTokens[requestToken];
        callback(urlDecode(data));
      });
    }
  }

})();
